

void study(void)
{
	//MD5码介绍
	if (1)
	{
		/*
			MD5是一种加密算法，
			特性：
				一个文件数据生成一个码，大多情况这个码是唯一对应的，但可能几个不同文件有相同的码
				一般来说是不可逆，无法破解的，即无法通过生成的码来推敲出源文件（但还是有暴力破解之类的）
			作用：
				因为文件与码唯一对应，故文件中一个数据被修改，那么生成的MD5码就会变化
				所以之前有学过 哈希表 就能用MD5码
				或者比如游戏数据的保护，当我们从手机上修改游戏数据时，这些数据传到服务器，服务器会根据数据生成MD5，来与之前服务器传出去的数据生成的MD5对比
					如果两个MD5不一样，那么说明数据被修改了。
			
		
		*/
	}
	//命令行参数
	if (2)
	{
		/*
			主函数参数，即用于程序接受数据之类，通用的只有前两个（个数、数据），第三个是VS编译器带的，存放一些环境配置信息（可打印查看）
				第三个参数是VS编译器特有的，可查看环境配置目录，其他编译器不支持不识别
			
			参数1：数量  参数2：数据具体是什么
				未传递的情况下默认是 1 个
				默认是本程序的exe文件，打印的也就是本程序exe的路径

			向本程序传递参数的方式
			运行传递 ：4种：1：系统cmd  2：右键--打开方式	  3：文件拖动  4：双击
				1.系统cmd ： cmd打开命令行提示符，找到本程序exe 或者把本程序exe拖进cmd中
							然后隔一个空格（必须，不然就是同一串了） 后面就是要传递的数据了，可以手打，也可以使用其它文件，什么都行，只要是数据
				2.右键--打开方式： 
							被传递的文件，右击打开方式，找到本程序exe，选择本程序打开文件即可
				
				3：文件拖动：被打开文件鼠标拖动到 本程序exe 即可打开
				4.双击：	
							比如我们双击doc文件，默认wps打开，是因为wps软件已经配置到系统环境下了
							要想我们的程序能双击打开某后缀文件，必须配置环境
			调试传递：
				本工程--右击：属性--调试--命令参数   就可指定调试时使用的是哪个文件了（传递的文件）
				仅调试时使用，程序生成的exe文件还是需要运行传递
			
		
		
		
		*/
	}
	//获取文件字节数
	if (3)
	{
		/*
			思路：
				1.用fopen_s 打开文件，设置文件指针
				2.fseek指定文件指针指向的位置，本次为了获取字节数用了SEEK_END
				3.ftell 获取文件指针的位置（下标），因为上一步指向了文件结尾的eof 所以下标位置 数值上等于 文件字节数
		*/
	}
	//满组数据处理逻辑
	if (4)
	{
		/*
			MD5中，64字节为一组，是这种算法的特性，并非人为控制
			一个文件，生成MD5时，从头开始，每64字节的数据拿出来，生成一个码，依次类推，把所有生成的码累积起来就是MD5码了

			注意点：	文件的结尾，也必须满足64字节，不够的就填充（填充100000...000，按位补齐） 一个字节8位，第一个要补齐的字节填1000 0000 十六进制为0x80 ，不能写1，因为这样该字节就不是1开头了，此后的字节填0即可
					要注意，结尾要留出8字节来存储数据量，就是说除了文件本身，要有额外8字节，末尾的那组64字节不够装，就额外申请一组

			两种处理方式：
					1.一次申请足够大空间，能把文件每64字节组全装进去				（效率更高）
					2.用一个64字节空间，依次遍历文件，每生成一个码，就清空去算下一个	（空间利用率更高）
		*/
	}
	//最后一组数据量 > 0 && <= 56 字节时
	if (5)
	{
		/*
			末尾要留8字节来存文件总数据量
				末尾8字节空间整合到一起，强转成某一数据类型（这样的话，读取这8字节时，就要按转成的类型来读，不要一个字节一个字节的读，不然不知道那些数字代表什么）
			未填满56字节时，尾元素到末尾8字节之间的空间要 按位填充 100000....
				因为是按位，故第一个需要填充的字节的8位必须是 1000 0000  十六进制为0x80 ，不能写1，因为这样该字节就不是1开头了
				后面要填充的字节填0就可以了，只要保证第一个需要填充的按位是 1000 0000 即可
			注意代码中的边界问题，因为用到下标，所以计算边界时要注意
		
		*/
	}
	//最后一组是满组的情况 即 = 64时
	if (6)
	{
		/*
			末尾那组是满组的话（满64字节）
				1.重新申请一组的空间
				2.末尾8字节记录数据量
				3.从下标0开始到末尾8字节，按位填充 10000000...
		*/
	}
	//最后一组 > 56 && < 64 字节时
	if (7)
	{
		/*
			末尾那组的字节数，不够留出8字节空间的情况
				1.将这组末尾按位填充10000000...
				2.重新申请一组64字节空间
				3.新申请的空间末尾8字节存储数据量，前面的空间全填充0
		*/
	}
	//4个 MD5运算需要的 缓冲器常数（工作常用到的知识）
	if (8)
	{
		/*
			常数：就是固定已知的值，比如2Πr 中 2Π （圆周率）就是已知常数
				MD5运算需要用到4个常数
					1.每个常数 4字节 大小
					2.16进制数：0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF 0xFE 0xDC 0xBA 0x98 0x76 0x54 0x32 0x10 (观察发现16进制：0~F 正序再倒叙)
						参与运算：4个字节为一组，按上面的顺序，每4字节为一组，分为4个，分别为
						第1个：0x01 0x23 0x45 0x67 第2个：0x89 0xAB 0xCD 0xEF 以此类推
					3.unsigned int MD5_1 = 0X67452301 、 unsigned int MD5_2 = 0xEFCDAB89 、 unsigned int MD5_3 = 0x98BADCFE 、 unsigned int MD5_3 = 0x10325476
						观察发现：这四个就是16进制的那4个字节组合而成的。采用小端存储（低地址位存到低数据位）

				这4个常数就是我们MD5运算所需要的
					看代码如何将4字节组合成一个常数的：
						1.用一个数组将所有16字节的数存起来
						2.用一个刚好占4字节的数据类型，来强转数组，这样用下标就能清晰的使用对应4字节的常数了，省去小端存储的麻烦

		*/
	}
	//另一种常数：64元素常数组
	if (9)
	{
		/*
			该常数组，有64个固定的常数
				常数的计算方式：4294967296乘以abs(sin(i))后得到的值的整数部分（i是弧度，abs是函数，sin是正弦）
				具体计算看代码
			可以上网找了之后复制
		*/
	}
	//最后一种常数 16元素常数组（转换例程函数）
	if (10)
	{
		/*
			怎么来的老师从文档上没找到
				介绍：
					总的16个元素，每4个元素为一组，分为了4组
					4组进行运算时，按照顺序依次使用，1组用完，下次轮到2组、然后3组、4组，再回到1组

		*/
	}
	///四个缓冲器算法
	if (11)
	{
		/*
			四个算法是已经规定好的了，固定的算法，固定的顺序
			顺序不能变，1就是1，按照1234的顺序来进行运算
				1.  ((x & y) | ((~x) & z))
				2.  ((x & z) | ( y & (~z)))
				3.  (x ^ y ^ z)
				4.  (y ^ (x | (~z)))
			其中的 x y z ，也就是我们之前的 4个缓冲器常数 的其中3个 是一种组合
		*/
	}
	//生成1个新的MD5值(核心算法函数)
	if (12)
	{
		/*
			函数构造：
				NewMD5(md5_1, md5_2, md5_3, md5_4, 数据数组[i]，64常数组[i]，16常数组[i])
				解析：	前4个参数：4个缓冲器常数。 数据数组[i]：就是程序接收的文件进行64字节分组后的那些组
						64常数组[i]：64元素常数组	 16常数组[i]：16元素常数组
						传参时，md5_1 会按照4个缓冲器常数，有顺序的轮换着传递给md5_1，即每次运算的md5_1是不同的
			计算方式：
				计算的方式是已经固定了的，我们复制就好
				计算方式一定不要打错，都是固定好了的
				
		
		*/
	}
	//第1轮生成MD5值（依次生成4个新的缓冲器）
	if (13)
	{
		/*
			
		 
			有64个常数，所以总共生成64次，每个MD5值生成16次
			第1轮：
			[ABCD 0 7 1]	[DABC 1 12 2]	[CDAB 2 17 3]	[BCDA 3 22 4]
			[ABCD 4 7 5]	[DABC 5 12 6]	[CDAB 6 17 7]	[BCDA 7 22 8]
			[ABCD 8 7 9]	[DABC 9 12 10]	[CDAB 10 17 11] [BCDA 11 22 12]
			[ABCD 12 7 13]	[DABC 13 12 14] [CDAB 14 17 15] [BCDA 15 22 16]
			
			顺序是固定的，不能变，请看代码中的注释，发现是有规律可循的
				注意参考表里的参6 其实是实际函数的末尾参数，顺序有调整
				实际函数多了一个参数，就是 四个缓冲器算法 的函数 第1轮用1 2用2 这样轮换
				NewMD5(md5_1, md5_2, md5_3, md5_4, 数据数组[i]，64常数组[i]，16常数组[i])
					其中64常数组[i] 的下标与参考表中的数字不是对应的，应该比参考表-1 因为下标从0开始
				64常数的初始化函数	必须在主函数最开始，不然会出错，因为生成MD5要用到这个常数

			第2轮：
			[ABCD 1 5 17] [DABC 6 9 18] [CDAB 11 14 19] [BCDA 0 20 20]
			[ABCD 5 5 21] [DABC 10 9 22] [CDAB 15 14 23] [BCDA 4 20 24]
			[ABCD 9 5 25] [DABC 14 9 26] [CDAB 3 14 27] [BCDA 8 20 28]
			[ABCD 13 5 29] [DABC 2 9 30] [CDAB 7 14 31] [BCDA 12 20 32]

			第3轮：
			[ABCD 5 4 33] [DABC 8 11 34] [CDAB 11 16 35] [BCDA 14 23 36]
			[ABCD 1 4 37] [DABC 4 11 38] [CDAB 7 16 39] [BCDA 10 23 40]
			[ABCD 13 4 41] [DABC 0 11 42] [CDAB 3 16 43] [BCDA 6 23 44]
			[ABCD 9 4 45] [DABC 12 11 46] [CDAB 15 16 47] [BCDA 2 23 48]

			第4轮：
			[ABCD 0 6 49] [DABC 7 10 50] [CDAB 14 15 51] [BCDA 5 21 52]
			[ABCD 12 6 53] [DABC 3 10 54] [CDAB 10 15 55] [BCDA 1 21 56]
			[ABCD 8 6 57] [DABC 15 10 58] [CDAB 6 15 59] [BCDA 13 21 60]
			[ABCD 4 6 61] [DABC 11 10 62] [CDAB 2 15 63] [BCDA 9 21 64]
		*/
	}
	//将生成的MD5值存入到一个文件中，另外解决打印存储时补码，0不打印的问题
	if (14)
	{
		/*
				某些输出是：ffffffb8 把f去掉就是结果了（原因是x 16进制输出，不显示-数，是负数的话，会按位补码，结果就是我们看到f）
				解决方法：原因知道了是补码，负数的补码，那么把md5 的返回值改为unsigned char 就可以了，让它不能为负数（知识比较偏门，但是很好的补充）
				某些如：1 则代表01  0则代表00 想要输出好看也是需要分类打印的
				并且输出时，要考虑到小端存储问题

				分类：所有小于0f的单位数，不分类的话只打印 单位数，不打印0，要想打印0，就分类，所有小于0f的加上0
				存入文件：打开文件--写入数据--关闭文件  写入数据时采用fprintf，能指定写入格式，避免乱码

				测试：
					因为多了个存放文件的步骤，所有正常调试是会程序中止的
					正确步骤：
						先调试一次，让程序代码更新进exe文件中
						然后打开cmd控制台，找到exe文件，找到数据文件，找到存放MD5码的文件
						3个文件依次拖进控制台，每个文件间 用空格隔开，然后回车就行了
						文件顺序：exe文件、数据文件、存放文件
					上网找在线的MD5码加密来验证自己代码
		*/
	}
	//我个人的总结，与尚不清楚的点的回顾
	if (15)
	{
		/*
			MD5的总体流程总结：
				1.先算出3种常数：4个缓冲器常数、64元素常数组、16元素常数组
				2.最大的那层计算得出MD5值函数为：GetMD5
					GetMD5中有4轮运算，每一轮的参数顺序是固定的（每一轮的缓冲器算法，Md5_1是按照顺序变化的）
					每次小运算，如：D = NewMD5(D, A, B, C, Md5_1, pData[1], CS_64[1], CS1_2);
					要把NewMD5返回的值赋值给参数1来记录
					4轮运算过后，参数ABCD的改动要累加：pMd5[0] += A;（详情对比代码）
				3.每轮运算中的每次小运算是NewMD5函数（生成1个新的MD5值(核心算法函数)）
					函数构造：NewMD5(md5_1, md5_2, md5_3, md5_4, 缓冲器算法, 数据数组[i]，64常数组[i]，16常数组[i])
					函数中的算法是固定的，最终返回参数1
				4.四个缓冲器算法：
					每个算法都是固定的，顺序也是。GetMD5运算中，每一轮都按顺序用不同的缓冲器算法
				5.最终生成的值：
					恒定为16个数值合成，每俩位为一个数值
					生成的数值存放在：unsigned char md5[16] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 };
				6.获取数据函数是GetData ，也是主要的非计算逻辑
					涉及到将数据分组，然后每组都进行运算
					每组都进行一次GetMD5运算，每组运算后最后得到的md5，会累加存入pMd5（就是md5[16]分为4字节一个元素后的数组）

			此前不清楚的点：
				四个缓冲器算法：
					此前不知道它的3个参数有什么用，后来才知道，是在NewMD5函数中运算时就传递了的
					看来数学要补充一下了

		*/
	}
}
